[%


var stm_name: String;
for (stm in RC!StateMachineDef.allInstances)
{ 
stm_name=stm.name;
}

 var javaDate = new Native("java.text.SimpleDateFormat")("ddMMyyyy_hhmmss").
  format(new Native("java.util.Date"));
 var javaDateString = new String;
 javaDateString= javaDate.toString();

%]
theory [%=stm_name%]_[%=javaDateString%]
imports "Z_Machines.Z_Machine"
begin

subsection \<open> Introduction \<close>

text \<open> This theory file is to model the [%=stm_name%] state machine in Z Machine notations.\<close>

notation undefined ("???")

subsection \<open> type definition \<close>

datatype ('s, 'e) tag =
  State (ofState: 's) | Event (ofEvent: 'e)

abbreviation "is_Event x \<equiv> \<not> is_State x"

type_synonym ('s, 'e) rctrace = "('s, 'e) tag list"

definition wf_rcstore :: "('s, 'e) rctrace \<Rightarrow> 's \<Rightarrow> 's option \<Rightarrow> bool" where
[z_defs]: "wf_rcstore tr st final = (
     length(tr) > 0 
   \<and> tr ! ((length tr) -1) = State st 
   \<and> (final \<noteq> None \<longrightarrow> (\<forall>i<length tr. tr ! i = State (the final) \<longrightarrow> i= (length tr) -1)) 
   \<and> (filter is_State tr) ! (length (filter is_State tr) -1) = State  st)"
   
[%
for (p in RC!RCPackage) {
if (p.name="Chemical" or p.name="lre_beh"){
 
 
 
 
 
 
 
 
 
 
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the states  to generate enumtype
"Query the states".println();
//we assume there is ONLY ONE state machine in the package

 
var k=0;
var enum_output: String;
var set_output: String;

var enum_output_event: String;
var set_output_event: String;


 for (n in p.machines.at(0).nodes){
 enum_output= enum_output+ n.zmState() +" | ";
set_output= set_output+ n.zmState() +", ";}
 
//to add the context for thy file "enumtype St = "
//to cut the last vertical bar
enum_output= "enumtype St = " + enum_output.substring(0,(enum_output.length()-2));
%]
[%=enum_output%]
[%set_output= "definition [z_defs]: \"St = {" + set_output.substring(0,(set_output.length()-2))+"}\"";
%]
[%=set_output%] 


[%
//to generate enum for events
for (e in p.machines.at(0).events)
{ 
"print out the event names".println();
e.name.println();
 enum_output_event =  enum_output_event+ e.name +" | ";
set_output_event = set_output_event+ e.name +", ";
}

enum_output_event= "enumtype Evt = " + enum_output_event.substring(0,(enum_output_event.length()-2));
%]
[%=enum_output_event%]
[%set_output_event= "definition \"Evt = {" + set_output_event.substring(0,(set_output_event.length()-2))+"}\"";
%]
[%=set_output_event%] 


[%
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the TYPES
"////////////////////////////////////////////////////////////////////////////////".println();
"Query the types".println();
/////////////////////////////////////////////////////////////////////
//for Enumaration type
for (e in p.types)
{
e.type().name.println();
("e.name: " + e.name).println();
 if(e.type().name="Enumeration"){
 var enumtype_output: String;
 var enumtype_set_output: String;
 var i=0;
while(i<e.literals.size()){
enumtype_output=enumtype_output+ e.literals.at(i).name +" | ";
enumtype_set_output=enumtype_set_output+ e.literals.at(i).name +", ";
i++;
}
enumtype_output="enumtype "+ e.name + " = "+ enumtype_output.subString(0, (enumtype_output.length()-3));
("final enumtype_output: " +enumtype_output).println();
%]
[%=enumtype_output%]

[%enumtype_set_output="definition \""+ e.name + " = {"+ enumtype_set_output.subString(0, (enumtype_set_output.length()-2))+ "}\"";
("final enumtype_set_output: " +enumtype_set_output).println();%]
[%=enumtype_set_output%]
[%
 }
}

/////////////////////////////////////////////////////////////////////
//for Primitive type
for (e in p.types)
{
 if(e.type().name="PrimitiveType"){
  var primitiveType_output: String;
  primitiveType_output="type_synonym " + e.name + "= \"nat\"";
  primitiveType_output.println();%]
[%=primitiveType_output%]
[%}
 }


/////////////////////////////////////////////////////////////////////
//for Record type
"query for record type".println();
for (e in p.types)
{
 if(e.type().name="RecordType")
{%]record [%=e.name%] =
[% // var recordType_output: String;
  var i=0;
while(i<e.fields.size()){
(e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name).println();%]
  [%=e.fields.at(i).name%] :: [%=e.fields.at(i).Type.ref.name%]
[%//recordType_output=e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name;
i++;
}
("record_default " + e.name).println();%]
record_default [%=e.name%]
[%//recordType_output="record " + e.name + "= "+ recordType_output;
//("recordType_output: " + recordType_output).println();
 }
}
  
/////////////////////////////////////////////////////////////////////
//for Constants
"query for constants definition".println(); 
var const_string: String;
//PART 1: transfer all constants in Robochart
for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();
var i=0;
while(i< vrl.vars.size()){

if(vrl.vars.at(i).modifier.literal="CONST"){

if(vrl.vars.at(i).type.isTypeOf(TypeRef) or vrl.vars.at(i).type.isTypeOf(ProductType)){
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.zmType() +"\"";
("const_string: " +const_string).println();
 "".println();
}
if(vrl.vars.at(i).type.isTypeOf(SeqType)){
if(vrl.vars.at(i).type.domain.isTypeOf(ProductType)){
vrl.vars.at(i).name.println();

const_string="consts "+ vrl.vars.at(i).name+ " :: \""+ vrl.vars.at(i).type.domain.productString() +" list\"";

} else {
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.type.zmType() +" list\"";}
}
%][%=const_string%]
  [%
} i++;} }
 
////PART 2: generate consts for input events as the possible input set
 for (tr in p.machines.at(0).transitions){ 

//CASE 1 input event in transition.trigger
if(tr.trigger.isDefined() and tr.trigger._type.isDefined() and tr.trigger._type.name="INPUT")
{
if(tr.trigger.parameter.type.isTypeOf(TypeRef) or tr.trigger.parameter.type.isTypeOf(ProductType)){
const_string= "consts " + tr.trigger.parameter.name.firstToUpperCase() + " :: \"" + tr.trigger.parameter.type.zmType() + " set\"";
}
else 
if(tr.trigger.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.trigger.parameter.name.firstToUpperCase() + " :: \"((" + tr.trigger.parameter.type.domain.zmType() + ") list) set\"";

}%][%=const_string%]
  [%
}

//CASE 2 input event in transition.action, and there is only one action
if(tr.action.isDefined() and tr.action.isTypeOf(CommunicationStmt) and  tr.action.communication._type.name="INPUT"){

if(tr.action.communication.parameter.type.isTypeOf(TypeRef) or tr.action.communication.parameter.type.isTypeOf(ProductType)){
const_string= "consts " + tr.action.communication.parameter.name.firstToUpperCase() + " :: \"" + tr.action.communication.parameter.type.zmType() + " set\"";

} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.action.communication.parameter.name.firstToUpperCase() + " :: \"(" + tr.action.communication.parameter.type.zmType() + " list) set\"";
}
%][%=const_string%]
  [%
}


//CASE 3 input event in transition.action, and there are MULTIPLE actionS
if(tr.action.isDefined() and tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{
if(tr.action.statements.at(i).isTypeOf(CommunicationStmt) and  tr.action.statements.at(i).communication._type.name="INPUT"){
if(tr.action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){

const_string= "consts " + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() + " :: \"" + tr.action.statements.at(i).communication.parameter.type.zmType()+ " set\"";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() + " :: \"(" + tr.action.statements.at(i).communication.parameter.type.zmType() + " list) set\"";
}
%][%=const_string%]
  [%
}i++;
}}


//CASE 4 input event in tr.target.action, and there is only one action
if(tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.communication._type.name="INPUT"){


if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(ProductType) ){

const_string= "consts " + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase()+ " :: \"" + tr.target.actions.at(0).action.communication.parameter.type.zmType() +" set\"";

} 
else if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(SeqType)){

const_string= "consts Seq" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase()+ " :: \"(" + tr.target.actions.at(0).action.communication.parameter.domain.type.zmType() +" list) set\"";
}%][%=const_string%]
  [%
}

//CASE 5: input event in tr.target.action, action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{
if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT"){
if(tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){

const_string= "consts " + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase()+ " :: \"" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.zmType() +" set\"";

} 
else if(tr.target.actions.at(0).action.statements.at(i).parameter.type.isTypeOf(SeqType)){

const_string= "consts Seq" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase()+ " :: \"(" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.zmType() +" list) set\"";
}
%][%=const_string%]
  [%
}
i++;
}}}}
 
 
/////////////////////////////////////////////////////////////////////
//query for functions to generate ABSTRACT func
%]

text \<open> function definition \<close>

[%
//TO Transform functions into CONSTS for the UNSPECIFIED Functions
for (f in p.functions.select(s|s.name!="card"))
{ 

var func_type:String;
var function_string: String;

if(f.type.isTypeOf(ProductType) or f.type.isTypeOf(TypeRef)){
func_type=f.type.zmType();
} else if(f.type.isTypeOf(SeqType)){
if(f.type.domain.isTypeOf(ProductType)){
func_type="("+ f.type.domain.zmType()+")";}
else if(f.type.domain.isTypeOf(TypeRef)){
func_type=f.type.domain.zmType();
}
}

//CASE 1: single parameter
//pattern: consts f.name :: " parameter_type => f.type"
if(f.parameters.size()=1){
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"this is a SeqType".println();
if(f.parameters.at(0).type.domain.isTypeOf(ProductType)){
function_string="consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType()+" list \\<Rightarrow> "+ func_type+"\"";
} else {
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType() +" list \\<Rightarrow> "+ func_type+"\"").println();
function_string="consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType() +" list \\<Rightarrow> "+ func_type+"\"";}
} 
 if(f.parameters.at(0).type.isTypeOf(TypeRef) or f.parameters.at(0).type.isTypeOf(ProductType)){
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ func_type+"\"").println();
//function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.ref.name +" \\<Rightarrow> "+ f.type.ref.name+"\"";
function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ func_type+"\"";
}
}
//CASE 2: multiple parameters, we will need pXp pattern in ZM
//pattern: consts f.name :: " parameter_type (X parameter_type)* => f.type"
else if(f.parameters.size()>1){

// generate the first part of parameter
if(f.parameters.at(0).type.isTypeOf(SeqType)){
if(f.parameters.at(0).type.domain.isTypeOf(ProductType)){
function_string= f.parameters.at(0).type.domain.zmType()+" list";
} else {
function_string= f.parameters.at(0).type.domain.zmType() +" list";}
} 
 if(f.parameters.at(0).type.isTypeOf(TypeRef) or f.parameters.at(0).type.isTypeOf(ProductType)){
function_string= f.parameters.at(0).type.zmType();
} 

// generate the rest part of parameter: (X parameter_type)*
var i=1;
while(i<f.parameters.size()){


if(f.parameters.at(i).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
if(f.parameters.at(i).type.domain.isTypeOf(ProductType)){
function_string= function_string+" \\<times> " +f.parameters.at(i).type.domain.productString()+ " list";
} else {
f.parameters.at(i).type.domain.ref.name.println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.domain.zmType()+ " list";}
} 
if(f.parameters.at(i).type.isTypeOf(TypeRef)){
f.parameters.at(i).type.zmType().println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.zmType();
} 
if(f.parameters.at(i).type.isTypeOf(ProductType)){
function_string=function_string+" \\<times> " + f.parameters.at(i).type.zmType();
}

i++;
}
function_string="consts "+f.name+ " :: \" "+function_string+" \\<Rightarrow>"+ func_type+"\"";
"OUTPUT FUNCTION STRING:".println();
function_string.println();

}

%]
[%=function_string%]
[%

}
%]

subsection \<open> State Space \<close>
[%
/////////////////////////////////////////////////////////////////////
//query for the statemachine and variables and consts TO generate zstore
"variable query TO generate zstore".println();
var stm_name: String;
for (stm in p.machines){ 
//("stm.name: "+stm.name).println();
stm_name=stm.name;
}%]

zstore [%=stm_name%] =
[%
//Part 1 of zstore is variables from variableLsit
for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();

var i=0;
while(i< vrl.vars.size()){
//vrl.vars.at(i).at(0).type.println();
var variable_string: String;
if(vrl.vars.at(i).modifier.literal="VAR"){
if(vrl.vars.at(i).type.isTypeOf(TypeRef) or vrl.vars.at(i).type.isTypeOf(ProductType)){
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.zmType() +"\"";
}
else if(vrl.vars.at(i).type.isTypeOf(SeqType)){
if(vrl.vars.at(i).type.domain.isTypeOf(ProductType)){
variable_string=vrl.vars.at(i).name+ " :: \" " + vrl.vars.at(i).type.domain.productString() +" list\"";} else 
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.zmType() +" list\"";
}
}%]  [%=variable_string%]
  [%i++;} }
%]  st::"St"
  tr :: "(St, Evt) tag list"
  triggers:: "Evt set"
  where inv: 
    "wf_rcstore tr st (Some final)"

subsection \<open> Operations \<close>

[%
//query for the transitions TO zoperations
"transitions query TO generate zoperations".println();
//zoperations_string is used for zmachine section
//zoperations_set is used for the lemma of structural invariant section
var zoperations_string:String;
var zoperations_set: OrderedSet;
var zop_name: String;

//this para_string is a set to contain all the parameter in para segment, and will be used for lemma generation

for (tr in p.machines.at(0).transitions){ 
var para_string: OrderedSet;

"START NEW TRANSITION QUERY".println();
("tr.name: "+tr.name).println();

zop_name=tr.source.zmStateCapt()+"To"+tr.target.zmStateCapt();
zop_name.println();
var indexOfOp=1;

//for multiple transitions between same source and target, we add index
//e.g., MOMToOCM_2
while (zop_name.isSubstringOf(zoperations_string)){
zop_name =tr.source.zmStateCapt()+"To"+tr.target.zmStateCapt()+"_"+indexOfOp.asString();
indexOfOp++;
}

//**************************************************************
//to define a tuple for this transition to link the hasPara with the zop
//this is for the lemma generation. If a zoperation has a para, then we need l in the lemma
//if zoperation has no para, then we add () in the lemma
var zop_tuple = new Tuple;
zop_tuple.name = zop_name;
zop_tuple.hasPara = false;
zop_tuple.paras = para_string;


zoperations_string=zoperations_string+" "+ zop_name;

%]
zoperation [%=zop_name%] =
  over [%=stm_name%]
[%
//////////////////////////////////////////////////////
//query for the transitions TO generate params section using Input type events
//CASE 1 input event in transition.trigger

var params_string:String;
params_string="";
if(tr.trigger.isDefined() and tr.trigger._type.isDefined() and tr.trigger._type.name="INPUT")
{

if(tr.trigger.parameter.type.isTypeOf(TypeRef) or tr.trigger.parameter.type.isTypeOf(ProductType)){
params_string=params_string+ tr.trigger.parameter.name+"_input \\<in> \"" + tr.trigger.parameter.name.firstToUpperCase() +"\" ";
}
else 
if(tr.trigger.parameter.type.isTypeOf(SeqType)){
params_string= params_string+ tr.trigger.parameter.name+"_input \\<in> \"Seq" + tr.trigger.parameter.name.firstToUpperCase() +"\" ";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.trigger.parameter.name);
}

//CASE 2 input event in transition.action, and there is only one action
if(tr.action.isDefined() and tr.action.isTypeOf(CommunicationStmt) and  tr.action.communication._type.name="INPUT"){

if(tr.action.communication.parameter.type.isTypeOf(TypeRef) or tr.action.communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.action.communication.parameter.name+"_input \\<in> \"" + tr.action.communication.parameter.name.firstToUpperCase()+"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.communication.parameter.name+"_input \\<in> \"Seq" + tr.action.communication.parameter.name.firstToUpperCase() +"\" ";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.communication.parameter.name);
}


//CASE 3 input event in transition.action, and there are MULTIPLE actionS
if(tr.action.isDefined() and tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{
if(tr.action.statements.at(i).isTypeOf(CommunicationStmt) and  tr.action.statements.at(i).communication._type.name="INPUT"){
if(tr.action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+"_input \\<in> \"" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+"_input \\<in> \"Seq" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.statements.at(i).communication.parameter.name);
}i++;}}


//CASE 4 input event in tr.target.action, and there is only one action
if(tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){
if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.communication._type.name="INPUT"){

if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name + "_input \\<in> \"" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name + "_input \\<in> \"Seq" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase() +"\" ";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.communication.parameter.name);
}

//CASE 5: input event in tr.target.action, action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{
if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT"){
if(tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+"_input \\<in> \"" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.target.actions.at(0).action.statements.at(i).parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+"_input \\<in> \"Seq" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\"";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.statements.at(i).communication.parameter.name);
}i++;}}}



if(zop_tuple.hasPara){%]
  params [%=params_string %]
[%
}
zoperations_set.add(zop_tuple);


//////////////////////////////////////////////////////
//query the transitions TO generate pre section
//SUBSECTION 1: state constraint: current state st(source) 
var pre_string: String;
pre_string="pre \"st= "+tr.source.zmState();

//SUBSECTION 2: transition condition -> pre
if (tr.condition.isDefined() )
{
("tr.condition: " + tr.condition).println();
pre_string=pre_string+" \\<and> "+ tr.condition.binaryExpString();
}

var tr_string:String;

//SUBSECTION 3:transition trigger of Simple/input/output event  -> this should be converted to a 'pre' section
if(tr.trigger.isDefined()and tr.trigger.event.isDefined() ){
//pre_string=pre_string+" \\<and> trg=Some "+ tr.trigger.event.name;
tr_string= "@ [Event "+tr.trigger.event.name+"]";
}


//SUBSECTION 4:transition reset  to pre (TIME property)
if(not tr.reset.isEmpty() ){
tr.name.println();
tr.reset.clock.name.println();
pre_string=pre_string+" \\<and> clock=0";
}
pre_string=pre_string+"\"";
pre_string.println();
%]
  [%=pre_string%]
[%

//////////////////////////////////////////////////////
//query for the transitions TO generate UPDATE section
%]
  update "[st\<Zprime>= [%=tr.target.zmState()%]
  		  [%

if(zop_tuple.hasPara){
for (p in zop_tuple.paras){
%]
         ,[%=p%]\<Zprime> =[%=p%]_input
[%}}

//SUBSECTION 1:transition action to update
if (tr.action.isDefined() )
{
//("tr.action: " + tr.action).println();
var tr_action_string:String;

//CASE 1: "SeqStatement" means there are MORE THAN ONE actions.
if(tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{

if(tr.action.statements.at(i).isTypeOf(Assignment)){

//CASE a, there is no input event in this transition
//this is the default setting: "not zop_tuple.hasPara"
tr_action_string=","+tr.action.statements.at(i).left.name.name+"\\<Zprime> = "+tr.action.statements.at(i).right.oneSideOfBianryString();

//CASE b, there is input event, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(tr_action_string))
//then it means input var is used as parameter in an assignment
{tr_action_string=tr_action_string.replace(p, (p+"_input"));
}
} 
%]
         [%=tr_action_string%]
[%
} else if(tr.action.statements.at(i).isTypeOf(CommunicationStmt)){

if(tr.action.statements.at(i).communication._type.name="SIMPLE" or tr.action.statements.at(i).communication._type.name="INPUT" or tr.action.statements.at(i).communication._type.name="OUTPUT"){
tr_string=tr_string+"@ [Event "+tr.action.statements.at(i).communication.event.name +"]";
}
}i++;}}


//CASE 2: single action in tr.actions
else if(tr.action.isTypeOf(CommunicationStmt)){
if(tr.action.communication._type.name="SIMPLE" or tr.action.communication._type.name="INPUT" or tr.action.communication._type.name="OUTPUT"){
tr_string=tr_string+"@ [Event "+tr.action.communication.event.name +"]";
}}
}


/////////////////////////////////////////////////////////////////////
//query for the target state enter action TO generate update section
if(tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){
var target_action_string: String;

//CASE 1: action.isTypeOf(Assignment)
if(tr.target.actions.at(0).action.  isTypeOf(Assignment)){


//CASE a, there is no input event involved in this target action
target_action_string=tr.target.actions.at(0).action.left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.right.oneSideOfBianryString();

//CASE b, there is input event involved, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(target_action_string))
{target_action_string=target_action_string.replace(p, (p+"_input"));
}} 
%]
         ,[%=target_action_string%]
[%
}
//CASE 2: action.isTypeOf(Call)
else if(tr.target.actions.at(0).action.isTypeOf(Call)){
target_action_string=tr.target.actions.at(0).action.callString();
%]
          ,[%=target_action_string%]
[%
}

//CASE 3: action.isTypeOf(CommunicationStmt)
else if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt)){
if(tr.target.actions.at(0).action.communication._type.name="SIMPLE" or tr.target.actions.at(0).action.communication._type.name="INPUT" or tr.target.actions.at(0).action.communication._type.name="OUTPUT"){
target_action_string="event_"+tr.target.actions.at(0).action.communication.event.name +"\\<Zprime> = True";
tr_string=tr_string+"@ [Event "+tr.target.actions.at(0).action.communication.event.name +"]";
}
}

//CASE 4: action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{
if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Assignment)){

//CASE a, there is no input event involved in this target action
target_action_string=tr.target.actions.at(0).action.statements.at(i).left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.statements.at(i).right.oneSideOfBianryString();

//CASE b, there is input event involved, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(target_action_string))
//then it means input var is used as parameter in an assignment
{target_action_string=target_action_string.replace(p, (p+"_input"));
}
} 
%]
          ,[%=target_action_string%]
[%}
else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Call)){
target_action_string=tr.target.actions.at(0).action.statements.at(i).callString();
%]
          ,[%=target_action_string%]
[%}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt)){
if(tr.target.actions.at(0).action.statements.at(i).communication._type.name="SIMPLE" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="OUTPUT"  ){
tr_string=tr_string+"@ [Event "+tr.target.actions.at(0).action.statements.at(i).communication.event.name  +"]";
}}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Wait)){
target_action_string="clock\\<Zprime> = clock + "+tr.target.actions.at(0).action.statements.at(i).duration.binaryExpString();
%]
          ,[%=target_action_string%]
[%
}
i++;
}
}
}
%]         ,tr\<Zprime> =tr [%=tr_string%] @ [State [%=tr.target.zmState()%]]
[% // next to generate 'trigger'   TODO
var triggers_string;
var numOfNewTrig=0;

for(t in p.machines.at(0).transitions.select(t|t.source.name=tr.target.name)){
if  (t.trigger.isDefined()and t.trigger.event.isDefined() and numOfNewTrig=0)
{numOfNewTrig++;
triggers_string=t.trigger.event.name;}
else if  (t.trigger.isDefined()and t.trigger.event.isDefined() and numOfNewTrig>=1)
{numOfNewTrig++;
triggers_string=triggers_string+", "+t.trigger.event.name;}
}     
%]         ,triggers\<Zprime> = {[%=triggers_string%]}
         ]"
        
[%
//'}' in the line below is the close end of transition for loop
}
%]

  
definition Init :: "[%=stm_name%] subst" where
  [z_defs]:
  "Init = 
  [st\<leadsto> ,
   tr\<leadsto> ,
   triggers\<leadsto> ,
   ]"
(*To be filled in by user*)
  
  
zmachine [%=stm_name%]Machine =
  init Init
  invariant [%=stm_name%]_inv
  operations [%=zoperations_string%] 


subsection \<open> Structural Invariants \<close>

lemma Init_inv [hoare_lemmas]: "Init establishes [%=stm_name%]_inv"
  by zpog_full

[%
var n=0;
while (n<zoperations_set.size())
{
if(zoperations_set.at(n)!="initial"){
if(zoperations_set.at(n).hasPara){

%]
lemma [%=zoperations_set.at(n).name%]_inv [hoare_lemmas]: "[%=zoperations_set.at(n).name%] [%=zoperations_set.at(n).paras.toparathString()%] preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
} else if(not zoperations_set.at(n).hasPara){
%]
lemma [%=zoperations_set.at(n).name%]_inv [hoare_lemmas]: "[%=zoperations_set.at(n).name%]() preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
}
}
n++;
}
%]

subsection \<open> Safety Requirements \<close>

zexpr R1 is ""

lemma  "Init establishes R1"
  by zpog_full

[%
var n=0;
while (n<zoperations_set.size())
{
if(zoperations_set.at(n)!="initial"){
if(zoperations_set.at(n).hasPara){

%]
lemma "[%=zoperations_set.at(n).name%] [%=zoperations_set.at(n).paras.toparathString()%] preserves R1 under [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
} else if(not zoperations_set.at(n).hasPara){
%]
lemma "[%=zoperations_set.at(n).name%]() preserves R1 under [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
}
}
n++;
}
%]

definition [z_defs]: "[%=stm_name%]_axioms = ()"

lemma [%=stm_name%]_deadlock_free: "[%=stm_name%]_axioms  \<Longrightarrow> deadlock_free [%=stm_name%]Machine" 
  unfolding [%=stm_name%]Machine_def
  by deadlock_free
 [%
// '}' in the line below is the close end of package scope: if (p.name="Chemical")
} 
}
%]
end

[%
operation OrderedSet toparathString(): String{
var str:String;
str=self.at(0);
var i=1;
while(i<self.size()){
str= str+", "+self.at(i);
i++;
}
str="("+str + ")";
return str;
}
%]





[*convert initial state name from i1 to initial, final j1 to final*]
[%
operation RC!Node zmState(): String{
  if(self.isTypeOf(Initial)){
  return "initial";
  } else if(self.isTypeOf(Final)){
    return "final";
  } else{
  return self.name;
  }
  }%]
  

[*convert initial state name from i1 to Initial, final j1 to Final*]
[%
operation RC!Node zmStateCapt(): String{
  if(self.isTypeOf(Initial)){
  return "Initial";
  } else if(self.isTypeOf(Final)){
    return "Final";
  } else{
  return self.name;
  }
  }%]
  
  
[*convert boolean type to bool type, real to integer*]
[%
operation RC!Type zmType(): String{
  if(self.isTypeOf(ProductType)){
  return "("+self.types.at(0).zmType() + "\\<times>" + self.types.at(1).zmType()+")";
  } else if(self.ref.name="boolean"){
  return "bool";
  } else if(self.ref.name="real"){
  return "integer";
  } else  {  
  return self.ref.name;
  }
  }%]
  
  
  
[%
operation RC!Expression binaryExpString(): String{
//"self.type".println();
//self.type.println();
if(self.isTypeOf(LessThan)){
return self.lessThanString();}
else if(self.isTypeOf(GreaterThan)){
return self.greaterThanString();}
else if(self.isTypeOf(LessOrEqual)){
return self.lessOrEqualString();}
else if(self.isTypeOf(GreaterOrEqual)){
return self.greaterOrEqualString();}
else if(self.isTypeOf(Equals)){
return self.equalsString();}
else if (self.isTypeOf(And)){
return self.andString();}
else if (self.isTypeOf(Or)){
return self.orString();}
else if (self.isTypeOf(Not)){
return self.notString();}
else if (self.isTypeOf(Plus)){
return self.plusString();}
else if (self.isTypeOf(Minus)){
return self.minusString();}
else if (self.isTypeOf(Mult)){
return self.multString();}
else if(self.isTypeOf(IntegerExp) or self.isTypeOf(RefExp) or self.isTypeOf(CallExp)  or self.isTypeOf(ResultExp) or self.isTypeOf(Selection) or self.isTypeOf(EnumExp) or self.isTypeOf(ArrayExp) or self.isTypeOf(TupleExp) or self.isTypeOf(ClockExp) or self.isTypeOf(SeqExp) ){
return self.oneSideOfBianryString();}
else if(self.isTypeOf(ParExp)){
return self.exp.binaryExpString();
}
}
%]
[%

operation RC!Expression lessThanString(): String{
return self.left.binaryExpString() +"<" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression lessOrEqualString(): String{
return self.left.binaryExpString() +"\\<le>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterThanString(): String{
return self.left.binaryExpString() +">" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterOrEqualString(): String{
return self.left.binaryExpString() +"\\<ge>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression equalsString(): String{
return self.left.binaryExpString() +"= (" + self.right.binaryExpString()+")";
}
%]
[%
operation RC!Expression andString(): String{
return self.left.binaryExpString() +" \\<and> " + self.right.binaryExpString();
}
%]

[%
operation RC!Expression orString(): String{
return "("+self.left.binaryExpString() +" \\<or> " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression notString(): String{
return "\\<not>" + self.exp.binaryExpString();
}
%]

[%
operation RC!Expression plusString(): String{
return "("+self.left.binaryExpString() +" + " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression minusString(): String{
return "("+self.left.binaryExpString() +" - " + self.right.binaryExpString()+")";
}
%]


[%
operation RC!Expression multString(): String{
return "("+self.left.binaryExpString() +" * " + self.right.binaryExpString()+")";
}
%]
[%
//DONE
//to return the string of left or right expression string of the binary expression
//currently covers 3 types: Integer, RefExp, CallExp
operation RC!Expression oneSideOfBianryString(): String{
if(self.isTypeOf(IntegerExp)){
return self.value.toString();
}
else if(self.isTypeOf(RefExp)){
return self.ref.name;
}
else if(self.isTypeOf(CallExp)){
return self.callExpString();
}
else if(self.isTypeOf(ResultExp)){
return "result";
}
else if(self.isTypeOf(Selection)){
return self.member.name+"("+self.receiver.value.ref.name+"!"+self.receiver.parameters.at(0).ref.name+")";
}

else if(self.isTypeOf(EnumExp)){
return self.literal.name;
}
else if(self.isTypeOf(SeqExp)){
return self.sequenceString();
}

else if(self.isTypeOf(ArrayExp)){
return self.value.ref.name + "."+self.parameters.at(0).value;
//e.g., vel[1] -> vel.1
}

else if(self.isTypeOf(TupleExp)){
return "("+ self.values.at(0).oneSideOfBianryString()+", "+self.values.at(1).oneSideOfBianryString() +")";
//e.g., (3,4)
}

else if(self.isTypeOf(ClockExp)){
return "clock";
}
}
 
 %]
  
 
  
  
  
[*to generate the CallExp expression string for the statement of CallExp type, i.e. functions*]
[% 
operation RC!CallExp callExpString(): String{
var args_string: String;
var callExp_string: String;
//to get the parameter on the right

if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){

if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
}
j++;
}

callExp_string=self.`function`.ref.name+"("+args_string+")";
return callExp_string;
}
  %]
  
  
  
  
  

[*to generate the Call expression string for the statement of Call type, i.e. operations*]
[% 
operation RC!Call callString(): String{
var args_string: String;
var call_string: String;
//to get the parameter on the right
if(self.args.size()=0){
args_string="";
}
else if(self.args.size()>0){
if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else if(self.args.at(0).isTypeOf(IntegerExp)){
args_string= self.args.at(0).value.toString();
}
else if(self.args.at(0).isTypeOf(EnumExp)){
args_string= self.args.at(0).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else if(self.args.at(j).isTypeOf(IntegerExp)){
args_string= args_string+ ", "+ self.args.at(j).value.toString();
}
else if(self.args.at(j).isTypeOf(EnumExp)){
args_string= args_string+ ", "+ self.args.at(j).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";

}

j++;
}
}
call_string=self.`operation`.name+"("+args_string+")";
return call_string;
}
  %]
  


  
[%
operation RC!SeqExp sequenceString(): String{

if(self.values.size()=0){
return  "[]";
} 
else if(self.values.size()>0) {
var m=1;
var sequence_string="["+self.values.at(0);
while (m<self.values.size()){
sequence_string=sequence_string+", "+self.values.at(m);
m++;
}
sequence_string=sequence_string+"]";
return sequence_string;
}
}
%]


[%
operation RC!ProductType productString(): String{
var strings: String;
strings= "("+self.types.at(0).zmType() + "\\<times>" + self.types.at(1).zmType()+")" ;
 return strings;
}
%]


